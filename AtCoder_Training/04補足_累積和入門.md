# 04補足_累積和入門

## 累積和をゼロから完全に理解する

この教材は、「累積和」について全く知識がない方向けに、基礎から丁寧に解説します。実生活での例えを交えながら、直感的に理解できるよう心がけています。

## 目次

1. [累積和とは何か](#1-累積和とは何か)
2. [日常生活の例で理解する](#2-日常生活の例で理解する)
3. [累積和の計算方法](#3-累積和の計算方法)
4. [累積和を使った区間の和の求め方](#4-累積和を使った区間の和の求め方)
5. [Pythonでの実装](#5-pythonでの実装)
6. [問題の解説：区間和クエリ](#6-問題の解説区間和クエリ)
7. [累積和の応用例](#7-累積和の応用例)
8. [練習問題](#8-練習問題)
9. [まとめ](#9-まとめ)

---

## 1. 累積和とは何か

### 累積和の基本概念

「**累積和**」とは、配列などのデータ構造において、先頭から各位置までの要素の和を事前に計算しておくテクニックです。

これにより、特定の区間（範囲）の和を高速に計算できるようになります。

例えば、以下のような数列があるとします：
```
[3, 1, 5, 4, 2]
```

この数列の累積和は次のようになります：
```
[0, 3, 4, 9, 13, 15]
```

ここでの各値は以下を表します：
- 0番目：0（便宜上の初期値）
- 1番目：0 + 3 = 3（最初の要素まで）
- 2番目：3 + 1 = 4（最初から2番目の要素まで）
- 3番目：4 + 5 = 9（最初から3番目の要素まで）
- 4番目：9 + 4 = 13（最初から4番目の要素まで）
- 5番目：13 + 2 = 15（最初から5番目＝全要素の和）

### なぜ累積和を使うのか？

累積和を計算しておくと、**どの区間の和も O(1)（定数時間）で計算できる**ようになります。これにより、区間の和に関する問題を効率的に解けるようになります。

例えば、上記の数列で2番目から4番目までの和を求めたい場合：
- 素直に計算する方法：5 + 4 + 2 = 11（区間の長さだけの計算が必要）
- 累積和を使う方法：13 - 4 = 9（常に2回の計算で済む）

あれ？結果が合わないようですが、これは**インデックスの扱い方**に気をつける必要があるからです。正しい区間の和の求め方は後ほど詳しく説明します。

---

## 2. 日常生活の例で理解する

### 例1：財布の中のお金を数える

毎日、あなたは財布にお金を追加しています。月初めから現在までの財布の中身を記録したいとします。

```
1日目: 500円入れた
2日目: 100円入れた
3日目: 300円入れた
4日目: 200円入れた
5日目: 400円入れた
```

もし、**3日目までに財布に入れたお金の合計**を知りたい場合は？
- 直接計算：500 + 100 + 300 = 900円

もし、**2日目から4日目までに入れたお金の合計**を知りたい場合は？
- 直接計算：100 + 300 + 200 = 600円

しかし、こんな計算を何度も行うのは面倒です。そこで、**累積和**を使います。

**累積和表**を作成します：
```
0日目まで: 0円（初期値）
1日目まで: 0 + 500 = 500円
2日目まで: 500 + 100 = 600円
3日目まで: 600 + 300 = 900円
4日目まで: 900 + 200 = 1100円
5日目まで: 1100 + 400 = 1500円
```

この表を使えば、例えば**2日目から4日目までに入れたお金の合計**は：
- 4日目までの合計(1100円) - 1日目までの合計(500円) = 600円

これは、2日目、3日目、4日目に入れたお金（100円 + 300円 + 200円）に等しいです。

### 例2：走行距離計

車の走行距離計は、実は累積和の一例です。

1. 1日目に30km走行
2. 2日目に20km走行
3. 3日目に25km走行
4. 4日目に15km走行
5. 5日目に10km走行

この場合、**オドメーターの表示**（累積走行距離）は：
```
0日目：0km
1日目：0 + 30 = 30km
2日目：30 + 20 = 50km
3日目：50 + 25 = 75km
4日目：75 + 15 = 90km
5日目：90 + 10 = 100km
```

もし**2日目から4日目までの走行距離**を知りたい場合：
- 4日目までの総走行距離(90km) - 1日目までの総走行距離(30km) = 60km

これは、2日目、3日目、4日目の走行距離（20km + 25km + 15km）に等しいです。

---

## 3. 累積和の計算方法

### 数列の累積和を求める手順

1. 元の数列の長さが N なら、累積和の配列は長さ N+1 で作成する（0番目の要素は0で初期化）
2. 以下の漸化式で埋めていく：
   ```
   S[0] = 0
   S[i] = S[i-1] + A[i-1]  (1≤i≤N)
   ```

ここで、S は累積和の配列、A は元の配列です。

### 例：具体的な数列での計算

元の数列 A = [7, 3, 2, 5, 1, 4]

累積和 S を計算します：
```
S[0] = 0（初期値）
S[1] = S[0] + A[0] = 0 + 7 = 7
S[2] = S[1] + A[1] = 7 + 3 = 10
S[3] = S[2] + A[2] = 10 + 2 = 12
S[4] = S[3] + A[3] = 12 + 5 = 17
S[5] = S[4] + A[4] = 17 + 1 = 18
S[6] = S[5] + A[5] = 18 + 4 = 22
```

これで、数列 A の累積和 S = [0, 7, 10, 12, 17, 18, 22] が得られました。

### 視覚的に理解する

```
元の配列 A：  [7, 3, 2, 5, 1, 4]
インデックス： 0  1  2  3  4  5

累積和 S：   [0, 7, 10, 12, 17, 18, 22]
インデックス：0  1   2   3   4   5   6
```

この累積和を使うと、例えば「インデックス1から4までの要素の和」は：
```
S[5] - S[1] = 18 - 7 = 11
```

これは A[1] + A[2] + A[3] + A[4] = 3 + 2 + 5 + 1 = 11 と一致します。

---

## 4. 累積和を使った区間の和の求め方

### 区間[L, R]の和の求め方

累積和 S を使って、元の配列 A のインデックス L から R までの和を求める公式は：

```
A[L] + A[L+1] + ... + A[R] = S[R+1] - S[L]
```

**なぜこの公式が成り立つのか？**

S[R+1] は A[0] から A[R] までの和を表します。
S[L] は A[0] から A[L-1] までの和を表します。

したがって、S[R+1] - S[L] は、
```
(A[0] + A[1] + ... + A[R]) - (A[0] + A[1] + ... + A[L-1])
```
となり、共通部分が消えて、
```
A[L] + A[L+1] + ... + A[R]
```
だけが残ります。

これはちょうど求めたい区間 [L, R] の和です。

### 配列のインデックスと1-indexedの注意

多くの競技プログラミング問題では、配列のインデックスが1から始まる（1-indexed）場合があります。この場合、累積和の使い方を少し調整する必要があります。

1-indexedの場合（インデックスが1から始まる場合）：
```
区間 [L, R] の和 = S[R] - S[L-1]
```

Pythonなどプログラミング言語では基本的に0-indexed（インデックスが0から始まる）なので、問題を解く際はインデックスの変換に注意しましょう。

---

## 5. Pythonでの実装

### 累積和の基本実装

```python
def calculate_cumulative_sum(arr):
    n = len(arr)
    cumsum = [0] * (n + 1)
    
    for i in range(n):
        cumsum[i + 1] = cumsum[i] + arr[i]
    
    return cumsum

# 例
arr = [7, 3, 2, 5, 1, 4]
cumsum = calculate_cumulative_sum(arr)
print(cumsum)  # [0, 7, 10, 12, 17, 18, 22]
```

### 区間和の計算

```python
def range_sum(cumsum, left, right):
    """
    インデックスleftからrightまでの区間和を計算（0-indexed）
    """
    return cumsum[right + 1] - cumsum[left]

# 例
arr = [7, 3, 2, 5, 1, 4]
cumsum = calculate_cumulative_sum(arr)

# インデックス1から4までの和（3 + 2 + 5 + 1 = 11）
print(range_sum(cumsum, 1, 4))  # 11
```

### 1-indexedに対応した区間和の計算

問題で1-indexedが使われている場合：

```python
def range_sum_1indexed(cumsum, left, right):
    """
    1-indexed表記でleftからrightまでの区間和を計算
    （内部では0-indexedに変換）
    """
    # 1-indexedから0-indexedに変換
    left_0indexed = left - 1
    right_0indexed = right - 1
    
    return cumsum[right_0indexed + 1] - cumsum[left_0indexed]

# 例
arr = [7, 3, 2, 5, 1, 4]
cumsum = calculate_cumulative_sum(arr)

# 1-indexedで2から5までの和（3 + 2 + 5 + 1 = 11）
print(range_sum_1indexed(cumsum, 2, 5))  # 11
```

---

## 6. 問題の解説：区間和クエリ

### 問題概要

```
問題:
長さNの数列A_1, A_2, ..., A_Nがあります。
Q個のクエリが与えられ、各クエリでは区間[L, R]が指定されます。
各クエリに対して、A_L + A_(L+1) + ... + A_Rの値を出力してください。

入力:
1行目: 数列の長さ N とクエリの数 Q
2行目: N個の整数 A_1, A_2, ..., A_N
3行目以降: Q行にわたって、各クエリの L_i と R_i (1-indexed)

出力:
Q行にわたって、各クエリの答えを出力
```

### 問題の解説

この問題は累積和の典型例です。複数のクエリに対して区間の和を効率的に計算する必要があります。

**アプローチ1: 素直に計算する（効率が悪い）**

各クエリごとに指定された区間の要素を足し合わせる方法：

```python
def naive_solution(arr, queries):
    for l, r in queries:
        # 1-indexedから0-indexedに変換
        l_idx = l - 1
        r_idx = r - 1
        
        # 区間の和を計算（毎回O(N)の計算が必要）
        range_sum = sum(arr[l_idx:r_idx + 1])
        print(range_sum)
```

この方法では、各クエリごとに O(N) の計算が必要で、全体で O(N*Q) の時間計算量となります。N と Q が大きい場合、処理が間に合わなくなります。

**アプローチ2: 累積和を使う（効率的）**

累積和を前計算しておき、各クエリでは O(1) の計算で区間和を求める方法：

```python
def efficient_solution(arr, queries):
    # 累積和を前計算（O(N)）
    n = len(arr)
    cumsum = [0] * (n + 1)
    for i in range(n):
        cumsum[i + 1] = cumsum[i] + arr[i]
    
    # 各クエリを処理（各クエリO(1)）
    for l, r in queries:
        # 1-indexedから0-indexedに変換
        l_idx = l - 1
        r_idx = r - 1
        
        # 累積和を使って区間の和を計算
        range_sum = cumsum[r_idx + 1] - cumsum[l_idx]
        print(range_sum)
```

この方法では、累積和の前計算に O(N) の時間がかかりますが、各クエリは O(1) で処理できるため、全体の時間計算量は O(N + Q) となり、効率的です。

### 入力例での動作確認

入力:
```
5 3
1 2 3 4 5
1 3
2 4
3 5
```

累積和を計算すると：
```
cumsum = [0, 1, 3, 6, 10, 15]
```

クエリ1: [1, 3] の区間和
- cumsum[3] - cumsum[0] = 6 - 0 = 6
- これは A[0] + A[1] + A[2] = 1 + 2 + 3 = 6 と一致

クエリ2: [2, 4] の区間和
- cumsum[4] - cumsum[1] = 10 - 1 = 9
- これは A[1] + A[2] + A[3] = 2 + 3 + 4 = 9 と一致

クエリ3: [3, 5] の区間和
- cumsum[5] - cumsum[2] = 15 - 3 = 12
- これは A[2] + A[3] + A[4] = 3 + 4 + 5 = 12 と一致

### 実装のポイント

1. **累積和配列のサイズ**: 元の配列が長さ N なら、累積和配列は長さ N+1 で作成する
2. **0番目の要素**: 累積和配列の0番目は常に0で初期化する
3. **インデックスの変換**: 問題が1-indexedを使っている場合、適切に0-indexedに変換する
4. **区間和の計算**: 区間 [L, R] の和は `cumsum[R+1] - cumsum[L]`（0-indexed）または `cumsum[R] - cumsum[L-1]`（1-indexed）

---

## 7. 累積和の応用例

### 2次元累積和

2次元配列（マトリックス）に対しても累積和を適用できます。これにより、長方形領域の和を O(1) で計算できます。

```python
# 2次元累積和の計算
def calculate_2d_cumsum(matrix):
    h = len(matrix)
    w = len(matrix[0])
    
    # 累積和配列を初期化（サイズは(h+1)×(w+1)）
    cumsum = [[0] * (w + 1) for _ in range(h + 1)]
    
    # 累積和を計算
    for i in range(h):
        for j in range(w):
            cumsum[i+1][j+1] = cumsum[i+1][j] + cumsum[i][j+1] - cumsum[i][j] + matrix[i][j]
    
    return cumsum

# 長方形領域の和を計算（左上(y1,x1)から右下(y2,x2)まで、0-indexed）
def rectangle_sum(cumsum, y1, x1, y2, x2):
    return cumsum[y2+1][x2+1] - cumsum[y1][x2+1] - cumsum[y2+1][x1] + cumsum[y1][x1]
```

### imos法（区間加算のテクニック）

累積和の応用として、「imos法」というテクニックがあります。これは区間に対する加算操作を効率的に行うための手法です。

例えば、「区間 [a, b] に値 v を加算する」という操作を複数回行った後、最終的な配列の状態を求める問題を考えます。

```python
# imos法の基本実装
def imos_method(n, operations):
    # 差分配列を初期化
    diff = [0] * (n + 2)
    
    # 各操作を処理
    for l, r, v in operations:
        diff[l] += v      # 区間開始位置で加算
        diff[r + 1] -= v  # 区間終了位置の次で減算
    
    # 累積和を計算して結果を得る
    result = [0] * (n + 1)
    for i in range(1, n + 1):
        result[i] = result[i - 1] + diff[i]
    
    return result[1:]  # インデックス1からnまでを返す
```

### いもす法による区間加算

例として、区間に対する加算操作を考えます：

```
配列: [0, 0, 0, 0, 0, 0]（長さ6）
操作1: 区間[1, 3]に2を加算
操作2: 区間[2, 4]に3を加算
操作3: 区間[3, 5]に1を加算
```

まず差分配列を作成します：
```
diff = [0, 2, 0, 0, -2, 0, 0]
```

操作1の後：
```
diff = [0, 2, 0, 0, -2, 0, 0]
```

操作2の後：
```
diff = [0, 2, 3, 0, -2, -3, 0]
```

操作3の後：
```
diff = [0, 2, 3, 1, -2, -3, -1]
```

最後に累積和を計算します：
```
result[0] = 0
result[1] = 0 + 2 = 2
result[2] = 2 + 3 = 5
result[3] = 5 + 1 = 6
result[4] = 6 + (-2) = 4
result[5] = 4 + (-3) = 1
result[6] = 1 + (-1) = 0
```

最終結果：
```
[2, 5, 6, 4, 1, 0]
```

これは、すべての操作を適用した後の配列の状態になります。

---

## 8. 練習問題

### 問題1: シンプルな区間和

**問題**：
長さ N の数列 A が与えられます。Q 個のクエリに答えてください。各クエリでは、区間 [L, R] が与えられるので、A_L + A_(L+1) + ... + A_R の値を求めてください。

**入力**：
```
5
1 3 5 7 9
3
1 3
2 4
3 5
```

**出力**：
```
9
15
21
```

### 問題2: 区間の平均値

**問題**：
長さ N の数列 A があります。Q 個のクエリが与えられ、各クエリでは区間 [L, R] が指定されます。各クエリに対して、A_L, A_(L+1), ..., A_R の平均値を求めてください。

**入力**：
```
5
10 20 30 40 50
3
1 3
2 4
3 5
```

**出力**：
```
20.0
30.0
40.0
```

### 問題3: 条件を満たす区間の数

**問題**：
長さ N の数列 A と整数 K が与えられます。和が K 以上となる連続する部分列の数を求めてください。

**入力**：
```
5 10
2 3 1 4 5
```

**出力**：
```
7
```

---

## 9. まとめ

### 累積和のポイント

1. **累積和の定義**：先頭から各位置までの要素の和を前計算しておく配列
2. **利点**：区間の和をO(1)で計算できる、クエリ処理が効率的
3. **計算方法**：累積和配列S[0]=0, S[i]=S[i-1]+A[i-1] (1≤i≤N)
4. **区間和の公式**：区間[L,R]の和 = S[R+1]-S[L]（0-indexed）
5. **応用**：2次元累積和、imos法など

### 累積和を使いこなすコツ

1. **インデックスに注意**：0-indexedか1-indexedかをきちんと確認する
2. **累積和配列のサイズ**：元の配列よりも1大きく作る（S[0]=0のため）
3. **前計算の意識**：累積和は「前計算」のテクニックであることを理解する
4. **問題への適用**：「区間の和」「区間の平均」など、累積和が適用できる問題を見極める

累積和は、競技プログラミングや実務でもよく使われる重要なアルゴリズムテクニックです。基本をしっかり理解して、様々な問題に応用できるようになりましょう！
