# 深さ優先探索（DFS）入門

## 1. 深さ優先探索（DFS）とは？

深さ優先探索（Depth-First Search、略してDFS）は、**グラフやツリーを探索するためのアルゴリズム**で、可能な限り「深く」進んでいき、それ以上進めなくなったら「戻る」という探索方法です。「行き止まりまで進み、戻って別の道を探す」という人間が迷路を探索する自然な方法に似ています。

### 日常生活での例え

**例1：迷路探索**

迷路を解くとき、あなたはどうしますか？多くの人は「とにかく一つの道を行けるところまで進み、行き止まりになったら引き返して別の道を試す」というアプローチを取ります。これがまさに深さ優先探索の考え方です。

**例2：ファイル検索**

PCのフォルダ内でファイルを探すとき、まず一つのフォルダを開き、その中のサブフォルダを次々と深く掘り下げていく方法。これも深さ優先的な探索です。

## 2. DFSのアルゴリズム

### 基本的な手順

1. **スタート地点を訪問済みとマークする**
2. **以下を再帰的に繰り返す：**
   - 現在地点から行ける未訪問の地点があれば、そこに移動し訪問済みとマークする
   - 行ける未訪問の地点がなければ、一つ前の地点に戻る（バックトラック）
3. **全ての可能な経路を探索したら終了**

### DFSの特徴

- **再帰関数での実装が直感的**：問題を小さな同じ形の問題に分割できる
- **スタックを使った非再帰実装も可能**：深さが大きい場合のスタックオーバーフローを避けられる
- **メモリ使用量が比較的少ない**：BFSよりも多くの場合メモリ効率が良い
- **必ずしも最短経路を見つけるわけではない**：BFSと違い、最初に見つかる経路が最短とは限らない

## 3. グリッド上での経路探索問題（基本編）

### 問題文
H×Wのグリッドがあり、各マスは'.'（通路）か'#'（壁）です。左上のマス(0,0)からスタートして、右下のマス(H-1,W-1)にゴールできるか判定してください。上下左右の隣接するマスにのみ移動できます。

### 考え方を整理する

この問題はDFSの典型的な応用例です：

1. **スタート地点(0,0)から探索開始**
2. **現在地から上下左右に移動可能か確認**：
   - グリッド内か？
   - 壁ではないか？
   - まだ訪問していないか？
3. **移動可能なら、そのマスに移動して再帰的に探索**
4. **ゴール(H-1, W-1)に到達したら「Yes」、全て探索しても到達できなければ「No」**

### 図解

3×4のグリッドを例に考えます：

```
....  スタート(0,0)から
.##.  深さ優先で探索
....  していきます
```

DFSによる探索経路の例：

```
1→2→3→4
↓     ↓
8←7←6←5
↓
9→10→11→12
```

数字は訪問順序。例えば：
- (0,0)からスタート
- 右(0,1)に移動
- さらに右(0,2)に移動
- さらに右(0,3)に移動
- 下(1,3)に移動
- 左(1,2)に移動できない（壁）ので、左(1,1)にも移動できない（壁）、左(1,0)に移動
- 下(2,0)に移動
- 右(2,1)に移動
- 右(2,2)に移動
- 右(2,3)に移動してゴールに到達

## 4. Pythonでの実装

### 再帰を使った実装

```python
def grid_dfs(grid, start, goal):
    H, W = len(grid), len(grid[0])
    visited = [[False] * W for _ in range(H)]
    
    def dfs(y, x):
        # グリッド外、壁、または訪問済みの場合
        if y < 0 or y >= H or x < 0 or x >= W:
            return False
        if grid[y][x] == '#':
            return False
        if visited[y][x]:
            return False
        
        # 訪問済みとマーク
        visited[y][x] = True
        
        # ゴールに到達したか
        if (y, x) == goal:
            return True
        
        # 上下左右に移動
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            if dfs(ny, nx):
                return True
        
        return False
    
    return dfs(start[0], start[1])

# 使用例
H, W = 3, 4
grid = [
    '....',
    '.##.',
    '....'
]
start = (0, 0)
goal = (H-1, W-1)
if grid_dfs(grid, start, goal):
    print("Yes")
else:
    print("No")
```

### スタックを使った非再帰実装

```python
def grid_dfs_iterative(grid, start, goal):
    H, W = len(grid), len(grid[0])
    visited = [[False] * W for _ in range(H)]
    
    stack = [start]
    visited[start[0]][start[1]] = True
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while stack:
        y, x = stack.pop()
        
        if (y, x) == goal:
            return True
        
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            
            if (0 <= ny < H and 0 <= nx < W and 
                grid[ny][nx] == '.' and not visited[ny][nx]):
                visited[ny][nx] = True
                stack.append((ny, nx))
    
    return False
```

## 5. DFSの応用パターン

### 1. 連結成分の検出
- グラフ内の連結している要素を見つける
- 例：画像内の同じ色の連続領域を検出

### 2. トポロジカルソート
- 有向グラフ内のノードを依存関係に従って並べる
- 例：タスクの実行順序を決める

### 3. サイクル検出
- グラフ内の循環経路を見つける
- 例：デッドロック検出

### 4. バックトラック法
- 制約充足問題を解くアルゴリズム
- 例：数独、ナンプレの解法

### 5. 全探索（組み合わせ生成）
- 全ての可能な組み合わせを生成する
- 例：部分集合の列挙

## 6. 実際の問題で解いてみよう

### 例題：島の数え上げ問題
H×Wのグリッドがあり、'.'は海、'#'は陸地を表します。隣接する陸地（上下左右）は同じ島とみなします。島の総数を数えてください。

#### 解法
```python
def count_islands(grid):
    H, W = len(grid), len(grid[0])
    visited = [[False] * W for _ in range(H)]
    island_count = 0
    
    def dfs(y, x):
        if y < 0 or y >= H or x < 0 or x >= W:
            return
        if grid[y][x] == '.' or visited[y][x]:
            return
        
        visited[y][x] = True
        
        # 上下左右を探索
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dy, dx in directions:
            dfs(y + dy, x + dx)
    
    for y in range(H):
        for x in range(W):
            if grid[y][x] == '#' and not visited[y][x]:
                island_count += 1
                dfs(y, x)
    
    return island_count

# 使用例
grid = [
    '.#..#',
    '.#...',
    '.....',
    '#...#',
    '.#...'
]
print(count_islands(grid))  # 出力: 5
```

### 例題：経路の全列挙
スタートからゴールまでの全ての経路を列挙してください。

#### 解法
```python
def find_all_paths(grid, start, goal):
    H, W = len(grid), len(grid[0])
    all_paths = []
    current_path = [start]
    visited = [[False] * W for _ in range(H)]
    
    def dfs(y, x):
        if (y, x) == goal:
            all_paths.append(current_path.copy())
            return
        
        visited[y][x] = True
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            
            if (0 <= ny < H and 0 <= nx < W and 
                grid[ny][nx] == '.' and not visited[ny][nx]):
                current_path.append((ny, nx))
                dfs(ny, nx)
                current_path.pop()  # バックトラック
        
        visited[y][x] = False  # バックトラックのため訪問状態を戻す
    
    visited[start[0]][start[1]] = True
    dfs(start[0], start[1])
    return all_paths
```

## 7. 練習問題

### 練習問題1：グラフの連結判定
N個の頂点とM本の辺からなる無向グラフが与えられます。頂点1から頂点Nに到達できるか判定してください。

#### ヒント
- 隣接リストでグラフを表現する
- 頂点1からDFSを開始し、頂点Nに到達できるか確認する

### 練習問題2：部分和問題（DFS版）
N個の整数と目標値Mが与えられます。整数のいくつかを選んで合計がMになるかどうか判定してください。

#### ヒント
- 各整数について「選ぶ」「選ばない」の2通りの選択肢がある
- DFSでこれらの選択肢を全て試す

### 練習問題3：経路制約付き迷路
H×Wの迷路があり、特定のチェックポイントを必ず通過してからゴールに到達する必要があります。その最短経路を求めてください。

#### ヒント
- 状態を (y, x, チェックポイント通過済みかどうか) とする
- DFSで全経路を探索し、最短のものを見つける

## 8. まとめ

深さ優先探索（DFS）は、以下のような問題に適用できる強力なアルゴリズムです：

1. **経路探索**：スタートからゴールへの経路を見つける
2. **連結性判定**：グラフの連結性を調べる
3. **領域分割**：連結した領域を見つける
4. **全探索**：全ての可能な組み合わせや状態を探索する

DFSを使いこなすコツ：

- 再帰関数を使うと実装が簡潔になることが多い
- 訪問状態の管理が重要
- バックトラックが必要な場合は訪問状態を元に戻すことを忘れない
- 深さが大きいグラフでは再帰の代わりにスタックを使う実装も検討する

DFSはグラフ理論の基本アルゴリズムの一つで、様々な問題解決に応用できます。特にグラフの全探索や深い探索が必要な場合に強力なツールとなります。

## 9. 発展的なトピック

- **インフォームドDFS**：ヒューリスティック関数を用いた探索順序の制御
- **反復深化DFS**：徐々に探索の深さ制限を増やして探索する手法
- **最適化問題へのDFS応用**：分析限定法などの最適化手法との組み合わせ
- **グラフの特性調査**：強連結成分、橋、関節点などの検出
- **メモ化再帰との組み合わせ**：動的計画法と組み合わせた効率的な探索

DFSは再帰アルゴリズムの美しい例であり、その考え方を理解することで、多くの複雑な問題を解くための基礎が身につきます。様々な問題に応用して、DFSの力を実感してみましょう！
