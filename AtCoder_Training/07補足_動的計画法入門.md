# 動的計画法（DP）入門

## 1. 動的計画法とは？

動的計画法（Dynamic Programming、略してDP）とは、**複雑な問題を部分問題に分解して解く**アルゴリズムの設計手法です。計算結果を記録しておき、同じ計算を何度も繰り返すことを避けることで、計算量を大幅に削減できます。

### 日常生活での例え

**例1：家計簿の合計金額**

毎日の出費を記録している家計簿があります。「先月1ヶ月間の合計支出はいくら？」と聞かれたとき、あなたはどうしますか？

- **非効率な方法**：毎回1日目から30日目まで全部足し直す
- **DPの考え方**：前日までの合計額に今日の出費を足すだけ（結果を記録しておく）

**例2：通学路の数え方**

学校までの道のりで、交差点ごとに右か上にしか進めないとします。家から学校までの通学路は何通りあるでしょう？

- 各交差点までの通学路の数を記録していけば、最終的に学校までの通学路の総数が分かります。

## 2. 動的計画法の基本的な考え方

### DPの基本ステップ

1. **部分問題を定義する**：大きな問題を小さな部分問題に分割
2. **漸化式を立てる**：部分問題間の関係性を数式で表現
3. **ベースケースを設定する**：最も小さな問題の解答を決める
4. **テーブルに結果を保存する**：一度計算した結果を記録
5. **ボトムアップに解く**：小さな問題から大きな問題へ

## 3. 階段を上る問題（基本編）

### 問題文
N段の階段があります。一度に1段または2段上ることができます。頂上までの上り方は何通りあるでしょうか？

### 考え方を整理する

まず、この問題をDPで解くために考えるべきことは：

1. **DP配列の定義**：dp[i] = i段目までの上り方の総数
2. **漸化式の導出**：i段目にたどり着く方法は？
   - (i-1)段目から1段上がってくる
   - (i-2)段目から2段上がってくる
   - よって dp[i] = dp[i-1] + dp[i-2]
3. **初期条件**：
   - dp[0] = 1（0段目、つまりスタート地点には1通りでたどり着ける）
   - dp[1] = 1（1段目には1通りでたどり着ける）

### 図解

```
段数:  0    1    2    3    4    5
     [1]  [1]  [2]  [3]  [5]  [8]
        ↗︎  ↗︎   ↗︎   ↗︎   ↗︎
       1段  1段  1段  1段  1段
        ↗︎   ↗︎   ↗︎   ↗︎
         2段  2段  2段  2段
```

3段目に着く方法は：
- 1段目から2段上がる → 1通り
- 2段目から1段上がる → 2通り
- 合計 = 3通り

4段目に着く方法は：
- 2段目から2段上がる → 2通り
- 3段目から1段上がる → 3通り
- 合計 = 5通り

## 4. Pythonでの実装

```python
def stairs_dp(N):
    # DPテーブル初期化
    dp = [0] * (N + 1)
    dp[0] = 1  # 0段目には1通りでたどり着ける
    
    # ボトムアップでDP
    for i in range(N):
        # i+1段目に行く
        if i + 1 <= N:
            dp[i + 1] += dp[i]
        # i+2段目に行く
        if i + 2 <= N:
            dp[i + 2] += dp[i]
    
    return dp[N]

# 使用例
print(stairs_dp(3))  # 出力: 3
print(stairs_dp(4))  # 出力: 5
print(stairs_dp(5))  # 出力: 8
```

## 5. 動的計画法の基本パターン

### 1. ナップサック問題
- 重さと価値が異なる品物から、重さの制限内で価値の合計を最大化する問題

### 2. 最長増加部分列（LIS）
- 数列の中で増加する部分列の最大長を求める問題

### 3. 編集距離（レーベンシュタイン距離）
- 2つの文字列間の差異を数値化する問題

### 4. 区間DP
- 区間を分割して最適解を求める問題

### 5. bit DP
- 状態を整数のビット表現で管理するDP

## 6. 実際の問題で解いてみよう

### 例題：コイン問題
硬貨が何種類かあり、合計金額がちょうどXになるように硬貨を選ぶ方法は何通りあるか？

#### 解法
```python
def count_ways(coins, X):
    dp = [0] * (X + 1)
    dp[0] = 1  # 0円を作る方法は1通り（何も選ばない）
    
    for coin in coins:
        for i in range(coin, X + 1):
            dp[i] += dp[i - coin]
    
    return dp[X]

# 使用例
coins = [1, 5, 10, 50, 100, 500]
X = 120
print(count_ways(coins, X))
```

### 例題：最大和部分配列問題
数列Aが与えられたとき、和が最大となる連続部分配列の和を求めよ。

#### 解法
```python
def max_subarray_sum(A):
    n = len(A)
    dp = [0] * n
    dp[0] = A[0]
    
    for i in range(1, n):
        dp[i] = max(A[i], dp[i-1] + A[i])
    
    return max(dp)

# 使用例
A = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(A))  # 出力: 6 (部分配列 [4, -1, 2, 1])
```

## 7. 練習問題

### 練習問題1：フィボナッチ数列
フィボナッチ数列の第N項を求めてください。ただし、F(0)=0, F(1)=1とし、F(n)=F(n-1)+F(n-2) (n≥2)とします。

#### ヒント
- DPテーブルを用意し、F(0)とF(1)の値を初期値として設定する
- i=2からNまでループを回し、F(i)=F(i-1)+F(i-2)を計算する

### 練習問題2：最小コスト経路
N×Mのグリッドがあり、各マスにはコストが書かれています。左上から右下まで、右または下にしか移動できません。最小コストの経路を求めてください。

#### ヒント
- dp[i][j] = マス(i,j)までの最小コスト
- dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j]

### 練習問題3：部分和問題
整数の集合Sと目標値Tが与えられたとき、Sの部分集合で合計がちょうどTになるものが存在するかを判定してください。

#### ヒント
- dp[i][j] = 最初のi個の整数を使って合計jを作れるかどうか（True/False）
- dp[i][j] = dp[i-1][j] or dp[i-1][j-S[i-1]]（S[i-1]を選ぶか選ばないか）

## 8. まとめ

動的計画法は、以下のような特徴を持つ問題に適用できます：

1. **最適部分構造**：大きな問題の最適解が部分問題の最適解から構成される
2. **重複する部分問題**：同じ部分問題が複数回現れる

動的計画法を使いこなすコツは：

- 状態を適切に定義すること
- 漸化式（状態遷移）を正しく立てること
- ベースケースを忘れないこと
- 計算順序（依存関係）を意識すること

これらを意識しながら、多くの問題を解いて感覚を養っていきましょう！

## 9. 発展的なトピック

- **メモ化再帰**：トップダウンアプローチのDP
- **空間最適化**：DP配列のサイズを削減する方法
- **経路復元**：最適解だけでなく、その経路も求める方法
- **確率DP**：確率を扱うDP
- **桁DP**：数の桁を使ったDP

動的計画法は多くのアルゴリズムコンテストや実務でも頻出の重要なテクニックです。基本をしっかり理解して、様々な問題に応用できるようになりましょう！
