# 幅優先探索（BFS）入門

## 1. 幅優先探索（BFS）とは？

幅優先探索（Breadth-First Search、略してBFS）は、**グラフやツリーを探索するためのアルゴリズム**で、スタート地点から等距離にある全ての点を探索してから、より遠い点の探索に移ります。まさに「幅優先」という名前の通り、近い順に調べていくアルゴリズムです。

### 日常生活での例え

**例1：波紋の広がり**

水面に石を投げ入れると、波紋が同心円状に広がります。これがBFSのイメージです。スタート地点（石を投げ入れた場所）から距離が1の点が最初に、距離が2の点がその次に...という具合に、距離が近い順に探索していきます。

**例2：伝言ゲーム**

ある人が情報を周囲の人に伝え、その人たちがさらに周囲に伝えていくとき、情報は最初の人から距離が近い人から順に広がっていきます。これもBFSの典型的な例です。

## 2. BFSのアルゴリズム

### 基本的な手順

1. **スタート地点をキューに入れる**
2. **キューが空になるまで以下を繰り返す：**
   - キューの先頭の頂点を取り出す
   - その頂点の隣接頂点で未訪問のものを全てキューに入れ、訪問済みとマークする

### BFSの特徴

- **最短経路を求められる**：スタートから各頂点への最短距離が分かる
- **幅優先の探索**：近い順に探索するため、近い解から見つかる
- **キューを使う**：探索する順番を管理するためにキューを使用する

## 3. グリッド上での最短経路問題（基本編）

### 問題文
H×Wのグリッドがあり、各マスは'.'（通路）か'#'（壁）です。左上のマス(0,0)からスタートして、右下のマス(H-1,W-1)までの最短距離を求めてください。上下左右の隣接するマスにのみ移動でき、各移動のコストは1です。

### 考え方を整理する

この問題はBFSの典型的な応用例です：

1. **スタート地点をキューに入れる**：(0,0)を始点として、距離を0に設定
2. **キューから取り出した地点から上下左右に移動**：移動先が有効なら、距離を+1してキューに追加
3. **ゴールに到達したら探索終了**：それまでに記録した距離が最短距離となる

### 図解

以下のような3×4のグリッドを考えます（'.'は通路、'#'は壁）：

```
....
.##.
....
```

BFSによる探索順序と各マスへの距離を図示すると：

```
0 1 2 3    スタート(0,0)から
1 # # 4    の距離を数字で
2 3 4 5    表しています
```

例えば：
- (0,0)からスタート（距離0）
- 右(0,1)と下(1,0)に移動（距離1）
- 右(0,2)と下左(2,0)に移動（距離2）
- 右(0,3)と右(2,1)に移動（距離3）
- 下(1,3)と右(2,2)に移動（距離4）
- 右下(2,3)に移動（距離5）
- ゴール(2,3)に到達（最短距離6）

## 4. Pythonでの実装

```python
from collections import deque

def grid_bfs(grid, start, goal):
    H, W = len(grid), len(grid[0])
    # 距離を記録する配列（-1は未訪問）
    dist = [[-1] * W for _ in range(H)]
    
    # 幅優先探索
    queue = deque([start])  # スタート位置をキューに入れる
    dist[start[0]][start[1]] = 0  # スタート位置の距離は0
    
    # 移動方向（上下左右）
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        y, x = queue.popleft()
        
        # ゴールに到達したら終了
        if (y, x) == goal:
            return dist[y][x]
        
        # 上下左右に移動
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            
            # グリッド内かつ壁でなく未訪問の場合
            if (0 <= ny < H and 0 <= nx < W and 
                grid[ny][nx] == '.' and dist[ny][nx] == -1):
                dist[ny][nx] = dist[y][x] + 1
                queue.append((ny, nx))
    
    # ゴールに到達できない場合は-1を返す
    return -1

# 使用例
H, W = 3, 4
grid = [
    '....',
    '.##.',
    '....'
]
start = (0, 0)
goal = (H-1, W-1)
print(grid_bfs(grid, start, goal))  # 出力: 6
```

## 5. BFSの応用パターン

### 1. マルチスタートBFS
- 複数の始点から同時にBFSを行う手法
- 例：複数の火元からの延焼シミュレーション

### 2. 0-1 BFS
- 辺の重みが0または1の場合の最短経路を求めるアルゴリズム
- デックを使って実装する

### 3. 双方向BFS
- スタートとゴールの両方からBFSを行い、途中で出会った時点で終了する手法
- 大きなグラフでの高速化に使われる

### 4. 状態空間のBFS
- 位置だけでなく、様々な「状態」をノードとしてBFSを行う
- 例：「鍵を持っている/いない」といった状態も考慮する迷路探索

## 6. 実際の問題で解いてみよう

### 例題：迷路脱出問題（追加情報あり）
H×Wの迷路があり、スタートからゴールまでの最短経路を求めます。ただし、途中に鍵があり、鍵を取らないと開かないドアがあります。

#### 解法
```python
from collections import deque

def maze_with_key(grid, start, goal, key_pos):
    H, W = len(grid), len(grid[0])
    # 状態: (y, x, has_key)
    # has_key: 0=鍵なし, 1=鍵あり
    
    # 訪問状態を記録（3次元配列）
    dist = [[[-1, -1] for _ in range(W)] for _ in range(H)]
    
    queue = deque([(start[0], start[1], 0)])  # スタート時点では鍵を持っていない
    dist[start[0]][start[1]][0] = 0
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        y, x, has_key = queue.popleft()
        
        # ゴールに到達したら終了
        if (y, x) == goal:
            return dist[y][x][has_key]
        
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            
            # グリッド外なら無視
            if not (0 <= ny < H and 0 <= nx < W):
                continue
                
            new_has_key = has_key
            
            # 鍵を拾った場合
            if (ny, nx) == key_pos:
                new_has_key = 1
                
            # ドアは鍵を持っていないと通れない
            if grid[ny][nx] == 'D' and new_has_key == 0:
                continue
                
            # 壁は通れない
            if grid[ny][nx] == '#':
                continue
                
            # 未訪問の状態なら訪問
            if dist[ny][nx][new_has_key] == -1:
                dist[ny][nx][new_has_key] = dist[y][x][has_key] + 1
                queue.append((ny, nx, new_has_key))
    
    return -1
```

### 例題：最短経路復元
迷路の最短経路を距離だけでなく、実際の経路（どのマスを通るか）も求めてください。

#### 解法
```python
from collections import deque

def shortest_path_with_reconstruction(grid, start, goal):
    H, W = len(grid), len(grid[0])
    dist = [[-1] * W for _ in range(H)]
    prev = [[None] * W for _ in range(H)]  # 経路復元用の配列
    
    queue = deque([start])
    dist[start[0]][start[1]] = 0
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        y, x = queue.popleft()
        
        if (y, x) == goal:
            break
        
        for dy, dx in directions:
            ny, nx = y + dy, x + dx
            
            if (0 <= ny < H and 0 <= nx < W and 
                grid[ny][nx] == '.' and dist[ny][nx] == -1):
                dist[ny][nx] = dist[y][x] + 1
                prev[ny][nx] = (y, x)  # 直前のマスを記録
                queue.append((ny, nx))
    
    # 経路復元
    if dist[goal[0]][goal[1]] == -1:
        return -1, []
    
    path = []
    current = goal
    while current != start:
        path.append(current)
        current = prev[current[0]][current[1]]
    path.append(start)
    path.reverse()  # スタートからゴールの順に並べ直す
    
    return dist[goal[0]][goal[1]], path
```

## 7. 練習問題

### 練習問題1：島の数え上げ
H×Wのグリッドがあり、'.'は海、'#'は陸地を表します。隣接する陸地（上下左右）は同じ島とみなします。島の総数を数えてください。

#### ヒント
- 各陸地マスを始点にBFSを行い、訪問済みの陸地はマークする
- 新しい陸地を見つけるたびに島のカウントを増やす

### 練習問題2：チーズ迷路
H×Wの迷路があり、'S'はスタート、'G'はゴール、数字は各種類のチーズを表します。全てのチーズを集めてからゴールに行く最短経路を求めてください。

#### ヒント
- 状態を(y, x, collected_cheese)とする
- collected_cheeseはビット列で、どのチーズを集めたかを表す

### 練習問題3：騎士の移動
チェス盤上で、騎士（ナイト）が指定された位置から別の位置に移動するための最小手数を求めてください。

#### ヒント
- 騎士の移動方向は8方向
- 盤外への移動は考えなくてよい

## 8. まとめ

幅優先探索（BFS）は、以下のような問題に適用できる強力なアルゴリズムです：

1. **最短経路問題**：グラフやグリッド上での最短経路を求める
2. **到達可能性判定**：あるノードから別のノードに到達できるか判定する
3. **連結成分の検出**：グラフの連結成分を見つける

BFSを使いこなすコツ：

- キュー（deque）を効率的に使う
- 訪問状態を適切に管理する
- 必要に応じて状態を拡張する（3次元以上の状態空間も考える）
- 最短経路を復元する方法も知っておく

幅優先探索はグラフ理論の基本アルゴリズムの一つで、多くのアルゴリズム問題の基礎となります。このアルゴリズムをマスターすることで、様々な探索問題に対応できるようになるでしょう！

## 9. 発展的なトピック

- **A*アルゴリズム**：ヒューリスティック関数を用いた効率的な最短経路探索
- **ダイクストラ法との違い**：重み付きグラフでの最短経路探索
- **BFSとDFSの使い分け**：問題に応じた適切なアルゴリズムの選択
- **グリッド上のトリック**：方向配列の効率的な使い方
- **メモリ効率の改善**：大規模グラフでのBFSの最適化

幅優先探索は単純なアルゴリズムですが、適切に応用することで複雑な問題も解くことができます。基本をしっかり理解して、様々な問題に挑戦してみましょう！
